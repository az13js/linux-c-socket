POSIX线程

POSIX Threads——POSIX线程，是POSIX的多线程标准，它规定了一系列的函数用于给应用
程序控制同时执行的多个工作流程，这些工作流程被称为“线程”。多线程是为了给应用
程序提供更好的性能表现：一，可以利用多个处理器核心来分摊计算工作；二，线程
可以共享内存资源，减少了跨工作流程通信的开销。

一，在程序中启动一条线程

在GNU/Linux编写POSIX线程需要包含头文件“pthread.h”，需要定义作为线程执行的代
码，需要调创建线程函数令定义的代码独立地执行起来。文件“03_hello_world.c”实现
了线程创建并向屏幕打印消息的功能。使用GCC编译文件“03_hello_world.c”需要加上
“-lpthread”参数{1}，例如：

gcc 03_hello_world.c -lpthread

执行编译好的程序，屏幕分别输出两条语句：“这个是线程函数”和“主程序执行完成”。
从程序的代码上可以看出，POSIX中创建线程的函数是“pthread_create”。
“pthread_create”的函数定义是：

int pthread_create(
    pthread_t                 *thread,
    const pthread_attr_t      *attr,
    void                      *(*start_routine)(void *),
    void                      *arg
);

第一个参数“thread”是类型为“pthread_t”的指针，实际上可以认为这是一个
“unsigned long int”的指针，启动线程时系统会把线程的ID{2}写入进去，所以需要传
一个指针。

第二个参数“attr”也是一个指针类型的参数，它的作用是配置线程运作的一些方式，
从“const”关键字可以看出，操作系统不会修改这个参数里面的内容。在一般情况下，
如果想使用默认的配置启动线程，可以传NULL，就像文件“03_hello_world.c”中那样，
其他情况下可以通过设置属性来改变线程运行的方式{3}。

设置“attr”和传给“pthread_create”函数之前，需要先用“pthread_attr_init”函数（调
用成功时返回0，失败时返回其它值）初始化结构体“pthread_attr_t”，例如文件
“04_attr.c”中的用法。“pthread.h”提供了一系列函数用于设置这个属性，也就是说不
推荐直接改“attr”参数中的内容。这些设置的函数主要以“pthread_attr_set”开头，分
别是（对应存在“pthread_attr_get”开头的函数用于获取属性值，这些函数较多且有些
是非GNU标准，这里列举一部分，获取属性的函数不列出来了，具体参考官网上对应的
文档）：

pthread_attr_setdetachstate
pthread_attr_setschedpolicy
pthread_setschedparam
pthread_attr_setinheritsched
pthread_attr_setscope

最后，“pthread_attr_destroy”函数用来销毁“attr”属性。在成功销毁（返回值0代表
成功，其它值是失败）后可以重新初始化，并且创建线程后销毁不影响创建出来的线
程。属性相关的函数返回值不具体列出，详细情况参考相关的文档。

第三个参数是一个函数指针，指向作为线程执行的函数代码。从“pthread_create”的函
数定义不难看出，该函数指针指向的函数返回值是“void *”，参数的入参是“void *”，
这个入参具体的内容由“pthread_create”函数的第四个参数决定。

第四个参数是一个“void *”类型的指针，这里具体传什么内容可以自由决定，
“pthread_create”会把这个参数传给线程函数。文件“04_attr.c”中，线程的函数
“thread_function”并没有使用参数“arg”，所以在进行“pthread_create”调用时可以
传“NULL”。

函数“pthread_create”成功执行时将返回0，失败的时候返回其它值。

文件“02_limit.c”中的代码尝试创建20000个线程但是会在中途创建失败而退出。操作
系统设置允许创建的线程数量是有限的，这个限制与线程栈的大小有关{4}。线程执行
完成后线程栈会释放。

{1} pthread并不是Linux的内置库，所以需要用“-l”指定连接的二进制库文件。
{2} 线程ID在“pthread.h”中的其它线程操作函数中可以使用。
{3} 有些属性是Linux还不支持的。
{4} 栈大小会在后续内容涉及。

二，线程创建时指定的若干属性

函数“pthread_create”的第二个参数可以配置创建的线程相关的属性，它是一个
“pthread_attr_t”类型的指针。线程创建的时候可以指定的属性包括：分离状态、调度
策略、调度参数、继承性、作用域、线程栈末尾的警戒缓冲区大小、线程栈的位置、
线程栈的大小。

分离状态。线程的分离状态有两种，可结合和可分离，默认不设置是可结合（有说法
不同的操作系统默认值不同）。这两种状态的区别是：可结合状态下线程能被主进程
或其它线程控制等待它结束；而可分离是进程执行后无法被控制，且它占用的资源在
它运行结束后由操作系统自动释放。这里说到的控制是指进程或者线程可以通过阻塞
函数等待指定的进程结束，在存在某些需要线程执行完成后再进行的操作时这种机制
可以发挥作用。线程的分离状态也可以在创建线程后再设置，所以实际上这两种状态
最大的区别是一种不会在线程退出后自动释放资源，另一种会。

文件“05_thread_attr_detach.c”和“06_thread_attr_join.c”分别用可分离和可结合的
状态创建同样功能的线程。“05”文件的线程是可分离的，所以线程和进程会同时输出，
而“06”文件的线程是可结合的，只有线程执行完成后主进程才会继续执行。

“05”的输出类似：

线程创建成功
进程正在运行
线程正在执行
线程正在执行
进程正在运行
线程正在执行
进程正在运行
进程执行完成，即将退出

“06”的输出类似：

线程创建成功
线程正在执行
线程正在执行
线程正在执行
pthread_join()调用完成
进程正在运行
进程正在运行
进程正在运行
进程执行完成，即将退出

除了这些特点之外，还有一些细节上的内容。“pthread_join”函数的定义是：

int pthread_join(pthread_t thread, void **retval);

第一个参数是线程ID。第二个参数用来存放线程返回的值，也就是示例中
“thread_function”函数返回的“void *”指针，不过目前为止示例代码都没有返回东西。
这里“retval”可以传NULL。如果线程已经结束那么“thread_function”函数会立刻返回。
“thread_function”函数成功返回0，失败返回非0值。具体参考官方文档。

文件“07_thread_join_free.c”实现的是不断创建线程并通过“pthread_join”等待线程
结束，可以在程序运行时查看它占用的内存，内存是不会逐渐增加的。这表明函数
“pthread_join”会在线程结束后释放它占用的内存空间。

文件“08_thread_join_memory_up.c”是设置线程可结合但是不使用“pthread_join”等待
它结束，运行时观察内存占用可以发现它的内存逐渐变大，这表明可结合的线程不用
“pthread_join”时不会在线程退出后释放线程内存的。

文件“09_thread_detach.c”是设置线程为可分离，然后不断创建线程。观察内存可以
发现内存占用并不会逐渐增加。



